## Календарь (calendar_events)

1) Откройте Supabase → SQL Editor → New query
2) Вставьте полностью `supabase_migrations_calendar.sql`
3) Run
4) Проверка:
   - Table: public.calendar_events
   - RLS: read/insert/update/delete policies
   - Realtime: таблица в публикации supabase_realtime

## Контроль качества (quality_control)

1) Откройте Supabase → SQL Editor → New query
2) Вставьте полностью `supabase_migrations_quality_control.sql`
3) Run
4) Проверка:
   - Tables: quality_checklists, quality_checks, quality_inspections, quality_inspection_results
   - RLS: read/manage policies для всех таблиц
   - Realtime: все 4 таблицы в публикации supabase_realtime
   - Демо-данные: 5 чек-листов (Стандартная проверка, 3D модели, Перед отгрузкой, Входной контроль, Экспресс)

## Материалы (materials)

1) Откройте Supabase → SQL Editor → New query
2) Вставьте полностью `supabase_migrations_materials.sql`
3) Run
4) Проверка:
   - Tables: materials, product_materials
   - RLS: read/manage policies для обеих таблиц
   - Realtime: обе таблицы в публикации supabase_realtime
   - Демо-данные: 15 материалов (ЛДСП, кромка, фурнитура, крепеж, покрытия, ткани)

# Инструкция по исправлению ошибок в Supabase

## Проблемы, которые мы исправляем:

1. ❌ `invalid input value for enum task_status: "review"` — отсутствует значение 'review' в ENUM
2. ❌ `invalid input value for enum project_status: "archived"` — отсутствует значение 'archived' в ENUM
3. ❌ `Could not find a relationship between 'task_comments' and 'profiles'` — неправильный foreign key
4. ❌ `Bucket not found` при работе с файлами — отсутствуют storage buckets

## Шаг 1: Откройте Supabase Dashboard

1. Перейдите на https://supabase.com/dashboard
2. Выберите проект `ubwtmdzdbxvxkeaawibi`
3. В левом меню выберите **SQL Editor**

## Шаг 2: Выполните миграции

### Миграция 1: Исправление ENUM и profiles

1. Нажмите **New query**
2. **Скопируйте** содержимое файла `supabase_migrations_fix_enums.sql` (см. ниже)
3. **Вставьте** в SQL Editor
4. Нажмите **Run** (или Ctrl+Enter)

### Миграция 2: Создание Storage Buckets

1. Нажмите **New query** (или используйте тот же)
2. **Скопируйте** содержимое файла `supabase_migrations_storage_buckets.sql` (см. ниже)
3. **Вставьте** в SQL Editor
4. Нажмите **Run** (или Ctrl+Enter)

## Шаг 3: Проверьте результат

После выполнения миграции проверьте, что:

### 3.1 ENUM типы обновлены

Выполните этот запрос:

```sql
SELECT e.enumlabel 
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
WHERE t.typname = 'task_status';
```

**Должно быть:** `backlog`, `todo`, `in_progress`, `review`, `done`

```sql
SELECT e.enumlabel 
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
WHERE t.typname = 'project_status';
```

**Должно быть:** `planning`, `active`, `completed`, `on_hold`, `archived`

### 3.2 Таблица profiles существует

```sql
SELECT * FROM public.profiles LIMIT 5;
```

Должны увидеть записи с вашими пользователями.

### 3.3 Foreign key правильный

```sql
SELECT 
  tc.constraint_name, 
  ccu.table_name AS foreign_table_name,
  ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_name = 'task_comments' 
  AND tc.constraint_type = 'FOREIGN KEY'
  AND kcu.column_name = 'author_id';
```

**Должно быть:** `foreign_table_name = profiles`, `foreign_column_name = id`

## Шаг 4: Проверьте Storage Buckets

1. В левом меню выберите **Storage**
2. Убедитесь, что созданы buckets:
   - `task-files` (для вложений в задачах)
   - `chat-audio` (для голосовых сообщений)

Если buckets нет, создайте их вручную:
- Нажмите **New bucket**
- Имя: `task-files` или `chat-audio`
- Public bucket: **Да** (включите)

## Шаг 5: Проверьте Realtime

1. В левом меню выберите **Database** → **Replication**
2. Убедитесь, что в таблице **supabase_realtime** есть:
   - `task_comments`
   - `profiles`
   - `tasks`
   - `projects`

Если каких-то таблиц нет, добавьте их вручную, нажав на **+** возле нужной таблицы.

## Шаг 6: Тестирование

Теперь попробуйте в приложении:

1. **Архивировать проект** — должно работать без ошибок
2. **Удалить архивный проект** — проект должен удалиться
3. **Перетащить задачу на "На ревью"** — задача должна переместиться
4. **Добавить комментарий к задаче** — комментарий должен отобразиться и остаться после перезагрузки
5. **Загрузить файл в задачу** — файл должен загрузиться и скачаться по клику

## Если что-то не работает

Откройте консоль браузера (F12) и пришлите:
- Сообщения об ошибках (красным)
- Логи с префиксами `[ARCHIVE]`, `[TASK-UPDATE]`, `[COMMENTS]`

---

## Содержимое файла миграции

Файл: `supabase_migrations_fix_enums.sql`

```sql
-- ================================================
-- FIX: Обновление ENUM типов для task_status и project_status
-- ================================================

-- 1. Добавляем отсутствующие значения в task_status
ALTER TYPE public.task_status ADD VALUE IF NOT EXISTS 'review';

-- 2. Добавляем отсутствующие значения в project_status
ALTER TYPE public.project_status ADD VALUE IF NOT EXISTS 'archived';

-- 3. Проверяем, что profiles существует и имеет правильную структуру
DO $$
BEGIN
  -- Если таблицы profiles нет, создаём
  IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = 'profiles') THEN
    CREATE TABLE public.profiles (
      id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      full_name text,
      email text,
      avatar_url text,
      created_at timestamptz NOT NULL DEFAULT now(),
      updated_at timestamptz NOT NULL DEFAULT now()
    );
    
    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
    
    CREATE POLICY "read profiles" ON public.profiles FOR SELECT USING (true);
    CREATE POLICY "update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
  END IF;
  
  -- Заполняем profiles из auth.users если пусто
  INSERT INTO public.profiles (id, email, full_name)
  SELECT 
    u.id,
    u.email,
    coalesce(u.raw_user_meta_data->>'full_name', u.email)
  FROM auth.users u
  WHERE u.id NOT IN (SELECT id FROM public.profiles)
  ON CONFLICT (id) DO NOTHING;
END $$;

-- 4. Обновляем внешний ключ task_comments.author_id
DO $$ 
BEGIN
  -- Удаляем старый constraint если он ссылается на auth.users
  IF EXISTS (
    SELECT 1 
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu 
      ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage ccu
      ON ccu.constraint_name = tc.constraint_name
    WHERE tc.table_name = 'task_comments' 
      AND tc.constraint_type = 'FOREIGN KEY'
      AND kcu.column_name = 'author_id'
      AND ccu.table_name = 'users'
  ) THEN
    ALTER TABLE public.task_comments DROP CONSTRAINT IF EXISTS task_comments_author_id_fkey;
    
    -- Создаём новый constraint на profiles
    ALTER TABLE public.task_comments 
    ADD CONSTRAINT task_comments_author_id_fkey 
    FOREIGN KEY (author_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
  END IF;
END $$;

-- 5. Создаём индексы для оптимизации
CREATE INDEX IF NOT EXISTS idx_task_comments_author ON public.task_comments(author_id);
CREATE INDEX IF NOT EXISTS idx_task_comments_task ON public.task_comments(task_id);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);

-- 6. Обновляем Realtime publication
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname='supabase_realtime' AND schemaname='public' AND tablename='profiles') THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
  END IF;
END $$;

COMMIT;
```

---

## Содержимое второй миграции

Файл: `supabase_migrations_storage_buckets.sql`

```sql
-- ================================================
-- FIX: Создание storage buckets для файлов
-- ================================================

-- 1. Создаём bucket для вложений задач
INSERT INTO storage.buckets (id, name, public)
SELECT 'task-files', 'task-files', true
WHERE NOT EXISTS (SELECT 1 FROM storage.buckets WHERE id='task-files');

-- 2. RLS политики для task-files bucket
DO $$ 
BEGIN
  -- Политика для чтения (публичный доступ)
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' 
    AND tablename = 'objects' 
    AND policyname = 'task files read'
  ) THEN
    CREATE POLICY "task files read" 
    ON storage.objects 
    FOR SELECT 
    USING (bucket_id = 'task-files');
  END IF;

  -- Политика для записи (только аутентифицированные)
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' 
    AND tablename = 'objects' 
    AND policyname = 'task files write'
  ) THEN
    CREATE POLICY "task files write" 
    ON storage.objects 
    FOR INSERT 
    TO authenticated 
    WITH CHECK (bucket_id = 'task-files');
  END IF;

  -- Политика для удаления (только аутентифицированные)
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' 
    AND tablename = 'objects' 
    AND policyname = 'task files delete'
  ) THEN
    CREATE POLICY "task files delete" 
    ON storage.objects 
    FOR DELETE 
    TO authenticated 
    USING (bucket_id = 'task-files');
  END IF;
END $$;

-- 3. Проверяем, что bucket chat-audio тоже существует (для голосовых сообщений)
INSERT INTO storage.buckets (id, name, public)
SELECT 'chat-audio', 'chat-audio', true
WHERE NOT EXISTS (SELECT 1 FROM storage.buckets WHERE id='chat-audio');

-- 4. RLS для chat-audio
DO $$ 
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' 
    AND tablename = 'objects' 
    AND policyname = 'chat audio read'
  ) THEN
    CREATE POLICY "chat audio read" 
    ON storage.objects 
    FOR SELECT 
    USING (bucket_id = 'chat-audio');
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'storage' 
    AND tablename = 'objects' 
    AND policyname = 'chat audio write'
  ) THEN
    CREATE POLICY "chat audio write" 
    ON storage.objects 
    FOR INSERT 
    TO authenticated 
    WITH CHECK (bucket_id = 'chat-audio');
  END IF;
END $$;

COMMIT;
```

