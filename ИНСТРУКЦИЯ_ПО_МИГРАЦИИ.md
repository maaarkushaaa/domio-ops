# Инструкция по исправлению ошибок в Supabase

## Проблемы, которые мы исправляем:

1. ❌ `invalid input value for enum task_status: "review"` — отсутствует значение 'review' в ENUM
2. ❌ `invalid input value for enum project_status: "archived"` — отсутствует значение 'archived' в ENUM
3. ❌ `Could not find a relationship between 'task_comments' and 'profiles'` — неправильный foreign key

## Шаг 1: Откройте Supabase Dashboard

1. Перейдите на https://supabase.com/dashboard
2. Выберите проект `ubwtmdzdbxvxkeaawibi`
3. В левом меню выберите **SQL Editor**

## Шаг 2: Выполните миграцию

1. Нажмите **New query**
2. **Скопируйте** содержимое файла `supabase_migrations_fix_enums.sql` (см. ниже)
3. **Вставьте** в SQL Editor
4. Нажмите **Run** (или Ctrl+Enter)

## Шаг 3: Проверьте результат

После выполнения миграции проверьте, что:

### 3.1 ENUM типы обновлены

Выполните этот запрос:

```sql
SELECT e.enumlabel 
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
WHERE t.typname = 'task_status';
```

**Должно быть:** `backlog`, `todo`, `in_progress`, `review`, `done`

```sql
SELECT e.enumlabel 
FROM pg_enum e
JOIN pg_type t ON e.enumtypid = t.oid
WHERE t.typname = 'project_status';
```

**Должно быть:** `planning`, `active`, `completed`, `on_hold`, `archived`

### 3.2 Таблица profiles существует

```sql
SELECT * FROM public.profiles LIMIT 5;
```

Должны увидеть записи с вашими пользователями.

### 3.3 Foreign key правильный

```sql
SELECT 
  tc.constraint_name, 
  ccu.table_name AS foreign_table_name,
  ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.table_name = 'task_comments' 
  AND tc.constraint_type = 'FOREIGN KEY'
  AND kcu.column_name = 'author_id';
```

**Должно быть:** `foreign_table_name = profiles`, `foreign_column_name = id`

## Шаг 4: Проверьте Realtime

1. В левом меню выберите **Database** → **Replication**
2. Убедитесь, что в таблице **supabase_realtime** есть:
   - `task_comments`
   - `profiles`
   - `tasks`
   - `projects`

Если каких-то таблиц нет, добавьте их вручную, нажав на **+** возле нужной таблицы.

## Шаг 5: Тестирование

Теперь попробуйте в приложении:

1. **Архивировать проект** — должно работать без ошибок
2. **Перетащить задачу на "На ревью"** — задача должна переместиться
3. **Добавить комментарий к задаче** — комментарий должен отобразиться

## Если что-то не работает

Откройте консоль браузера (F12) и пришлите:
- Сообщения об ошибках (красным)
- Логи с префиксами `[ARCHIVE]`, `[TASK-UPDATE]`, `[COMMENTS]`

---

## Содержимое файла миграции

Файл: `supabase_migrations_fix_enums.sql`

```sql
-- ================================================
-- FIX: Обновление ENUM типов для task_status и project_status
-- ================================================

-- 1. Добавляем отсутствующие значения в task_status
ALTER TYPE public.task_status ADD VALUE IF NOT EXISTS 'review';

-- 2. Добавляем отсутствующие значения в project_status
ALTER TYPE public.project_status ADD VALUE IF NOT EXISTS 'archived';

-- 3. Проверяем, что profiles существует и имеет правильную структуру
DO $$
BEGIN
  -- Если таблицы profiles нет, создаём
  IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = 'profiles') THEN
    CREATE TABLE public.profiles (
      id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      full_name text,
      email text,
      avatar_url text,
      created_at timestamptz NOT NULL DEFAULT now(),
      updated_at timestamptz NOT NULL DEFAULT now()
    );
    
    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
    
    CREATE POLICY "read profiles" ON public.profiles FOR SELECT USING (true);
    CREATE POLICY "update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
  END IF;
  
  -- Заполняем profiles из auth.users если пусто
  INSERT INTO public.profiles (id, email, full_name)
  SELECT 
    u.id,
    u.email,
    coalesce(u.raw_user_meta_data->>'full_name', u.email)
  FROM auth.users u
  WHERE u.id NOT IN (SELECT id FROM public.profiles)
  ON CONFLICT (id) DO NOTHING;
END $$;

-- 4. Обновляем внешний ключ task_comments.author_id
DO $$ 
BEGIN
  -- Удаляем старый constraint если он ссылается на auth.users
  IF EXISTS (
    SELECT 1 
    FROM information_schema.table_constraints tc
    JOIN information_schema.key_column_usage kcu 
      ON tc.constraint_name = kcu.constraint_name
    JOIN information_schema.constraint_column_usage ccu
      ON ccu.constraint_name = tc.constraint_name
    WHERE tc.table_name = 'task_comments' 
      AND tc.constraint_type = 'FOREIGN KEY'
      AND kcu.column_name = 'author_id'
      AND ccu.table_name = 'users'
  ) THEN
    ALTER TABLE public.task_comments DROP CONSTRAINT IF EXISTS task_comments_author_id_fkey;
    
    -- Создаём новый constraint на profiles
    ALTER TABLE public.task_comments 
    ADD CONSTRAINT task_comments_author_id_fkey 
    FOREIGN KEY (author_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
  END IF;
END $$;

-- 5. Создаём индексы для оптимизации
CREATE INDEX IF NOT EXISTS idx_task_comments_author ON public.task_comments(author_id);
CREATE INDEX IF NOT EXISTS idx_task_comments_task ON public.task_comments(task_id);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);

-- 6. Обновляем Realtime publication
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname='supabase_realtime' AND schemaname='public' AND tablename='profiles') THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles;
  END IF;
END $$;

COMMIT;
```

